class Solution {
public:
    int t[101][101][601];

    int solve(vector<pair<int,int>>& count, int m, int n, int i) {
        if (i >= count.size() || (m == 0 && n == 0)) {
            return 0;
        }

        if (t[m][n][i] != -1)
            return t[m][n][i];

        int take = 0;

        // If we can take this string
        if (count[i].first <= m && count[i].second <= n) {
            take = 1 + solve(count, m - count[i].first, n - count[i].second, i + 1);
        }

        // Skip this string
        int skip = solve(count, m, n, i + 1);

        return t[m][n][i] = max(take, skip);
    }

    int findMaxForm(vector<string>& strs, int m, int n) {
        int N = strs.size();
        vector<pair<int,int>> count(N);

        // Count 0s and 1s in each string
        for (int i = 0; i < N; i++) {
            int count0 = 0, count1 = 0;
            for (const char &ch : strs[i]) {
                if (ch == '0') count0++;
                else count1++;
            }
            count[i] = {count0, count1};
        }

        memset(t, -1, sizeof(t)); // âœ… initialize memo table
        return solve(count, m, n, 0);
    }
};
